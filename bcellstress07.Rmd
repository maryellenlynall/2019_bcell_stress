---
title: "Automated clustering"
output: html_document
---

Approach below largely based on (and code mainly adapted from) this paper: https://f1000research.com/articles/6-748/v2

Makes:
  - Figure 3A - automated clustering tSNE
  - Figure S4A - manual and automated subset comparison
  - Figure S13B - heatmap of marker expression for automated cluster detection
  - Figure S4B - automated counts volcano SD vs. HC
  - Figure 3F - effects of stress on flow marker expression
  - Figure 5E -  effects of Cd19-/- on flow marker expression

```{r}
library(tidyverse)
library(magrittr)
library(here)
library(readxl)
library(flowCore)
library(ggplot2)
library(reshape2)
library(RColorBrewer)
library(pheatmap)
library(tidyr)
library(ComplexHeatmap)

load(paste(here::here("res/"),'labels.manual.qced.Rmd',sep=""))
load(paste(here::here("res/"),'fcs_raw_qced.Rmd',sep=""))
load(paste(here::here("res/"),'data_bred.R',sep=""))
load(paste(here::here("res/"),'md.Rmd',sep=""))

## Define colors for conditions
color_conditions <- c("#6A3D9A", "#FF7F00")
names(color_conditions) <- levels(md$condition)
color_strains <- c("light grey", "purple")
names(color_strains) <- levels(md$strain)

# The TSNE is generated by this file (see later), but is slow to run, so just loading saved version from previous run versions of this file
load(paste(here::here("res/"),'men_tsne_out.R',sep="")) 
load(paste(here::here("res/"),'men_som_out.RData',sep="")) 

panel_filename <- "nih_panels.xlsx"

panel <- read_excel(paste(here::here("data/raw/facs/"),panel_filename,sep=""),sheet="meninges")
head(data.frame(panel),9)

```

Tidy
```{r}

panel_fcs <- pData(parameters(fcs_raw_qced[[1]]))
head(panel_fcs,9)
panel_fcs$desc <- gsub("-", "_", panel_fcs$desc)
(lineage_markers <- panel$Antigen[panel$Lineage == 1])
(functional_markers <- panel$Antigen[panel$Functional == 1])

# Check true
all(lineage_markers %in% panel_fcs$desc) 
all(functional_markers %in% panel_fcs$desc)

# NO TRANSFORM of fluorescence data needed (already done in FlowJo) i.e. fcs_Raw and fcs are the same except that we drop the uninteresting markers
fcs <- fsApply(fcs_raw_qced, function(x){
  colnames(x) <- panel_fcs$desc
  expr <- exprs(x)
  expr <- expr[, c(lineage_markers, functional_markers)]
  exprs(x) <- expr
  x
})
fcs

# Create matrix that is just the expression data 
expr <- fsApply(fcs, exprs)
dim(expr) 

```

Do a 0 to 1 transformation of some expression data which will be useful for visualization purposes (uses 1st and 99th percentile)
```{r}
library(matrixStats)
rng <- colQuantiles(expr, probs = c(0.01, 0.99))
expr01 <- t((t(expr) - rng[, 1]) / (rng[, 2] - rng[, 1]))
expr01[expr01 < 0] <- 0
expr01[expr01 > 1] <- 1
```

Diagnostic plots
```{r}
# Check the flowset is correctly ordered
cbind(fsApply(fcs_raw_qced,function(f) f@description$`$SRC`),md$sample_id) # the short filename. Consistent
sample_ids <- rep(md$sample_id, fsApply(fcs_raw_qced, nrow))
```

Verify cell numbers per sample
```{r}
# How many cell per sample?
(cell_table <- table(sample_ids))

ggdf <- data.frame(sample_id = names(cell_table),
  cell_counts = as.numeric(cell_table))
mm <- match(ggdf$sample_id, md$sample_id)
ggdf$condition <- md$condition[mm]
ggdf$strain <- md$strain[mm]

ggplot(ggdf, aes(x = sample_id, y = cell_counts, fill = condition)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = cell_counts), hjust=0.5, vjust=-0.5, size = 2.5) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  scale_fill_manual(values = color_conditions, drop = FALSE) +
  scale_x_discrete(drop = FALSE)
ggsave("men_leuco_plus_micro_per_sample_cond.png", path=here::here("pics/"), height = 7, width = 8) # Minimum is 5871

ggplot(ggdf, aes(x = sample_id, y = cell_counts, fill = strain)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = cell_counts), hjust=0.5, vjust=-0.5, size = 2.5) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  scale_fill_manual(values = color_strains, drop = FALSE) +
  scale_x_discrete(drop = FALSE)
ggsave("men_leuco_plus_micro_per_sample_strain.png", path=here::here("pics/"), height = 7, width = 8)

```

Median marker expression per sample
```{r}

library(dplyr)
# Get the median marker expression per sample
expr_median_sample_tbl <- data.frame(sample_id = sample_ids, expr) %>%
  group_by(sample_id) %>%  summarize_all(funs(median))

# Now just turn the table around for limma
expr_median_sample <- t(expr_median_sample_tbl[, -1])
colnames(expr_median_sample) <- expr_median_sample_tbl$sample_id
```

Cluster all samples using flowSOM

https://f1000research.com/articles/6-748/v2
"The FlowSOM workflow consists of three main steps. First, a self-organizing map (SOM) is built using the BuildSOM function, where cells are assigned according to their similarities to 100 (by default) grid points (or, so-called codebook vectors or codes) of the SOM. The building of a minimal spanning tree, which is mainly used for graphical representation of the clusters, is skipped in this pipeline. And finally, metaclustering of the SOM codes, is performed directly with the ConsensusClusterPlus function."

```{r}

fsApply(fcs,dim) 
# Select first 20k cells per sample or the total number of cells per sample, whichever is less.
# NB. There will be further sampling at tSNE stage

downsample <- fsApply(fcs, function(f){
  expr <- exprs(f)
  if (dim(expr)[1] > 20000) {
    expr <- expr[1:20000,]
  } else {
    expr <- expr
  }
  exprs(f) <- expr
  f
})

tmp <- fsApply(downsample,dim)
tmp
mean(tmp[,"events"]) 

# And make the downsampled 0 to 1 for visualization
expr_ds <- fsApply(downsample, exprs)
rng_ds <- colQuantiles(expr_ds, probs = c(0.01, 0.99))
expr01_ds <- t((t(expr_ds) - rng_ds[, 1]) / (rng_ds[, 2] - rng_ds[, 1]))
expr01_ds[expr01_ds < 0] <- 0
expr01_ds[expr01_ds > 1] <- 1

# And get a downsampled sample_ids
sample_ids_ds <- rep(md$sample_id, fsApply(downsample, nrow)) # length 983881

# Now do LM to check numbers not overrepresented in any condition:
data_bred$downsample_n <- fsApply(downsample,function(f) {dim(f)[1]}, simplify=TRUE)
fsApply(downsample,dim)
fit <- lm(downsample_n ~ cond + strain + coh, data=data_bred)
summary(fit) 
# Call:
# lm(formula = downsample_n ~ cond + strain + coh, data = data_bred)
# 
# Residuals:
#      Min       1Q   Median       3Q      Max 
# -12069.8   -182.8    182.8    997.2   4310.0 
# 
# Coefficients:
#             Estimate Std. Error t value Pr(>|t|)    
# (Intercept)  18029.6      970.1  18.586  < 2e-16 ***
# cond.L         493.2      507.4   0.972    0.336    
# straincd19     332.0      707.2   0.469    0.641    
# cohr4         1804.4     1277.5   1.412    0.165    
# cohr5         1804.4     1277.5   1.412    0.165    
# cohr6         1671.5     1293.6   1.292    0.203    
# cohr7         1804.4     1277.5   1.412    0.165    
# cohr8          624.4     1277.5   0.489    0.627    
# cohr9        -8607.9     1460.2  -5.895 4.81e-07 ***
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
# 
# Residual standard error: 2555 on 44 degrees of freedom
# Multiple R-squared:  0.6264,	Adjusted R-squared:  0.5585 
# F-statistic: 9.222 on 8 and 44 DF,  p-value: 2.394e-07
```

## FlowSOM clustering - uncomment this section to run
```{r}
library(FlowSOM)
# JUST LOAD ON RERUN AS SLOW
# fsom <- ReadInput(downsample, transform = FALSE, scale = FALSE)
# set.seed(4444)
# som <- BuildSOM(fsom, colsToUse = lineage_markers)
# ## Get the cell clustering into 100 SOM codes
# cell_clustering_som <- som$map$mapping[,1]

## Metaclustering into 20 clusters with ConsensusClusterPlus
#library(ConsensusClusterPlus)
#codes <- som$map$codes
#plot_outdir <- "consensus_plots"
#nmc <- 20 # Go up to 20 clusters

# JUST LOAD ON RERUN AS SLOW 
# mc <- ConsensusClusterPlus(t(codes), maxK = nmc, reps = 100,
#   pItem = 0.9, pFeature = 1, title = plot_outdir, plot = "png",
#   clusterAlg = "hc", innerLinkage = "average", finalLinkage = "average",
#   distance = "euclidean", seed = 1234)

code_clustering_k18 <- mc[[18]]$consensusClass 
cell_clustering_k18 <- code_clustering_k18[cell_clustering_som]

```

https://f1000research.com/articles/6-748/v2 :
"We can then investigate characteristics of identified clusters with heatmaps that illustrate median marker expression in each cluster (see Figure 6). As the range of marker expression can vary substantially from marker to marker, we use the 0-1 transformed data (expr01) for some visualizations. However, to stay consistent with FlowSOM and ConsensusClusterPlus, we use the (transformed in flowJo) unscaled data (expr) to generate the dendrogram of the hierarchical structure of metaclusters."

Function to plot per-cluster expression heatmap
```{r}
# Define cluster colors (here there are 30 colors), only using 20 for now
# See below
plot_clustering_heatmap_wrapper <- function(expr, expr01,
  cell_clustering, color_clusters, cluster_merging = NULL, filename, width, height){

  # Calculate the median expression
  expr_median <- data.frame(expr, cell_clustering = cell_clustering) %>%
    group_by(cell_clustering) %>% summarize_all(funs(median))
  expr01_median <- data.frame(expr01, cell_clustering = cell_clustering) %>%
    group_by(cell_clustering) %>% summarize_all(funs(median))

  # Calculate cluster frequencies
  clustering_table <- as.numeric(table(cell_clustering))
  clustering_prop <- round(clustering_table / sum(clustering_table) * 100, 2)

  # Sort the cell clusters with hierarchical clustering
  d <- dist(expr_median[, colnames(expr)], method = "euclidean")
  cluster_rows <- hclust(d, method = "average")

  expr_heat <- as.matrix(expr01_median[, colnames(expr01)])
  rownames(expr_heat) <- expr01_median$cell_clustering
  
  # Colors for the heatmap
  color_heat <- colorRampPalette(rev(brewer.pal(n = 9, name = "RdYlBu")))(100)
  legend_breaks = seq(from = 0, to = 1, by = 0.2)
  labels_row <- paste0(expr01_median$cell_clustering, " (", clustering_prop ,
    "%)")
     
  # Annotation for the original clusters
  annotation_row <- data.frame(Cluster = factor(expr01_median$cell_clustering))
  rownames(annotation_row) <- rownames(expr_heat)
  color_clusters1 <- color_clusters[1:nlevels(annotation_row$Cluster)]
  names(color_clusters1) <- levels(annotation_row$Cluster)
  annotation_colors <- list(Cluster = color_clusters1)
  
  # Annotation for the merged clusters
  if(!is.null(cluster_merging)){
    cluster_merging$new_cluster <- factor(cluster_merging$new_cluster)
    annotation_row$Cluster_merging <- cluster_merging$new_cluster
    color_clusters2 <- color_clusters[1:nlevels(cluster_merging$new_cluster)]
    names(color_clusters2) <- levels(cluster_merging$new_cluster)
    annotation_colors$Cluster_merging <- color_clusters2
  }

  pheatmap(expr_heat, color = color_heat, cluster_cols = FALSE,
   cluster_rows = cluster_rows, labels_row = labels_row,
   display_numbers = TRUE, number_color = "black",
   fontsize = 8, fontsize_number = 6,  legend=F,
   annotation_row = annotation_row, annotation_colors = annotation_colors, filename=filename, width=width,height=height)

}

```


tSNE prep
```{r}

## Find and skip duplicates (none detected)
dups <- which(!duplicated(expr_ds[, lineage_markers]))

## Data subsampling: create indices by sample
inds <- split(1:length(sample_ids_ds), sample_ids_ds)

## How many cells to downsample per-sample
tsne_ncells <- pmin(table(sample_ids_ds), 1000) # I have 53 samples so need this pretty low

## Get subsampled indices
set.seed(1234)
tsne_inds <- lapply(names(inds), function(i){
  s <- sample(inds[[i]], tsne_ncells[i], replace = FALSE)
  intersect(s, dups)
})

tsne_inds <- unlist(tsne_inds)
tsne_expr <- expr_ds[tsne_inds, lineage_markers]

```

UNCOMMENT TO RUN or load at start of file
Slow - uncomment to run this again, otherwise just load the pre-generated men_tsne_out.R at the start of the file
```{r}

## Run t-SNE
# library(Rtsne)
# set.seed(1111) 
# tsne_out <- Rtsne(tsne_expr, check_duplicates = FALSE, pca = FALSE)
# save(tsne_out, tsne_inds, file=paste0(here::here("res/"),"men_tsne_out.R"))
# save(cell_clustering_som, mc, file=paste0(here::here("res/"),"men_som_out.RData"))

```

Now add the manual gating results 
```{r}
library(RColorBrewer)
labels.manual.qced_ds <- lapply(labels.manual.qced,function(l){
  if (length(l) > 20000) {
    l <- l[1:20000]
  } else {
    l <- l
  }
  l
})

# Quick check:
sapply(labels.manual.qced_ds,length, simplify=TRUE)

# Convert downsampled labels to a long list
labels.manual.qced_ds <- matrix(unlist(labels.manual.qced_ds, use.names = FALSE), ncol = 1, byrow = TRUE)

# Now get downsampled (for tsne) - the 53k labels
tsne_labels <- labels.manual.qced_ds[tsne_inds]

```

Makes insets for Figure S3A
```{r}

# Plot t-SNE colored by various lineage markers
dr <- data.frame(tSNE1 = tsne_out$Y[, 1], tSNE2 = tsne_out$Y[, 2],
  expr_ds[tsne_inds, lineage_markers])

# Drop cluster with fewer than 0.1% of the cells (0.06%)
dr$drop <- TRUE
dr$drop[cell_clustering_k18[tsne_inds]==17] <- FALSE

ggplot(dr[dr$drop==TRUE,],  aes(x = tSNE1, y = tSNE2, color = B220)) +
  geom_point(size = 0.1) +
  theme_bw() +
  scale_color_gradientn("B220",
    colours = colorRampPalette(rev(brewer.pal(n = 11, name = "Spectral")))(50)) +
  coord_fixed()
ggsave("men_B220.png",path=here::here("pics/"),width=4,height=4)

ggplot(dr[dr$drop==TRUE,], aes(x = tSNE1, y = tSNE2, color = Ly6G)) +
  geom_point(size = 0.1) +
  theme_bw() +
  scale_color_gradientn("Ly6G",
    colours = colorRampPalette(rev(brewer.pal(n = 11, name = "Spectral")))(50)) +
  coord_fixed()
ggsave("men_Ly6G.png",path=here::here("pics/"),width=4,height=4)

ggplot(dr[dr$drop==TRUE,],  aes(x = tSNE1, y = tSNE2, color = Ly6C)) +
  geom_point(size = 0.1) +
  theme_bw() +
  scale_color_gradientn("Ly6C",
    colours = colorRampPalette(rev(brewer.pal(n = 11, name = "Spectral")))(50)) +
  coord_fixed()
ggsave("men_Ly6C.png",path=here::here("pics/"),width=4,height=4)

ggplot(dr[dr$drop==TRUE,],  aes(x = tSNE1, y = tSNE2, color = NK1p1)) +
  geom_point(size = 0.1) +
  theme_bw() +
  scale_color_gradientn("NK1p1",
    colours = colorRampPalette(rev(brewer.pal(n = 11, name = "Spectral")))(50)) +
  coord_fixed()
ggsave("men_NK1p1.png",path=here::here("pics/"),width=4,height=4)

ggplot(dr[dr$drop==TRUE,],  aes(x = tSNE1, y = tSNE2, color = CD3)) +
  geom_point(size = 0.1) +
  theme_bw() +
  scale_color_gradientn("CD3",
    colours = colorRampPalette(rev(brewer.pal(n = 11, name = "Spectral")))(50))+
  coord_fixed()
ggsave("men_CD3.png",path=here::here("pics/"),width=4,height=4)

ggplot(dr[dr$drop==TRUE,], aes(x = tSNE1, y = tSNE2, color = MHCII)) +
  geom_point(size = 0.1) +
  theme_bw() +
  scale_color_gradientn("MHCII",
    colours = colorRampPalette(rev(brewer.pal(n = 11, name = "Spectral")))(50))+
  coord_fixed()
ggsave("men_MHCII.png",path=here::here("pics/"),width=4,height=4)

ggplot(dr[dr$drop==TRUE,],  aes(x = tSNE1, y = tSNE2, color = CX3CR1)) +
  geom_point(size = 0.1) +
  theme_bw() +
  scale_color_gradientn("CX3CR1",
    colours = colorRampPalette(rev(brewer.pal(n = 11, name = "Spectral")))(50))+
  coord_fixed()
ggsave("men_CX3CR1.png",path=here::here("pics/"),width=4,height=4)

ggplot(dr[dr$drop==TRUE,],  aes(x = tSNE1, y = tSNE2, color = CD11c)) +
  geom_point(size = 0.1) +
  theme_bw() +
  scale_color_gradientn("CD11c",
    colours = colorRampPalette(rev(brewer.pal(n = 11, name = "Spectral")))(50))+
  coord_fixed()
ggsave("men_CD11C.png",path=here::here("pics/"),width=4,height=4)

ggplot(dr[dr$drop==TRUE,],  aes(x = tSNE1, y = tSNE2, color = CD4)) +
  geom_point(size = 0.1) +
  theme_bw() +
  scale_color_gradientn("CD4",
    colours = colorRampPalette(rev(brewer.pal(n = 11, name = "Spectral")))(50))+
  coord_fixed()
ggsave("men_CD4.png",path=here::here("pics/"),width=4,height=4)

```

Prep for tSNE plots
```{r}

# Repeat getting downsampled sample_ids
sample_ids_ds <- rep(md$sample_id, fsApply(downsample, nrow))

dr$sample_id <- sample_ids_ds[tsne_inds]
mm <- match(dr$sample_id, md$sample_id)
dr$condition <- md$condition[mm]
dr$coh <- md$coh[mm]
dr$strain <- md$strain[mm]
dr$manual_labels <- factor(tsne_labels)

```

```{r}

colors_manual = c(
  "#DC050C",  #13 red, B cells
  "#d4b7b7", #18 light purple, CD11b- DCs
  "#8600bf", #19 dark purple, CD11b+ DCs
  "#55A1B1",#14 blue-green MHCII- macs
  "#8DD3C7", #20 light turquoise, MHCII+ macs
  "#B17BA6", #5 violet, Ly6C+ monocytes
  "#E6AB02", #15 mustard, microglia
  "#882E72", #6 dark violet, neutrophils
  "#33A02C", #11 green, NK cells
  "#ffff00", #23 bright yellow, NKT cells (not seen by automated)
  "#1965B0", #3 blue, "pDCs"
  "#aeae5c", #9 moss, T cytotoxic
  "#FF7F00", #1 orange, T helper (half of)
  "grey79" #8 light grey, unknown
)

# Automated clustering colors 
color_clusters = c(
  "#882E72", #1 dark violet, neutrophils
  "#B17BA6", #2 violet, Ly6C+ monocytes
  "#FB8072", #3 peach, CX3CR1^{'+'}*Ly6C^{int}~monocyte
  "grey79", #4 light grey, ly6c- lymphoid
  "light blue", #5 light blue, CD4- pDCs
  "#d4b7b7", #6 light purple, CD11b- DCs
  "#8600bf", #7 dark purple, CD11b+ DCs
  "#E7298A", #8 fuchsia CX3CR1^{'-'}*Ly6C^{int}~monocytes
  "#1965B0", #9 blue, CD4+ pDCs
  "#aeae5c", #10 moss, ly6c- lymphoid
  "#FDB462",  #11 mute orange
  "#FF7F00", #12 orange, T helper (half of)
  "#8DD3C7", #13 light turquoise, MHCII+ macs
  "#55A1B1",#14 blue-green MHCII- macs
  "#33A02C", #15 green, NK cells
  "#E6AB02", #16 mustard, microglia
  "#DC050C"  #17 red, B cells
)


labeller=c("1"="(1)~Neutrophils",
"2"="(2)~Ly6C^{hi}~monocytes",
"3"="(3)~CX3CR1^{'+'}*Ly6C^{int}~monocytes",
"4"="(4)~Ly6C^{'+'}~lymphoid", 
"5"="(5)~CD4^{'-'}~pDCs", # dark purple 
"6"="(6)~CD11b^{'-'}~DCs",
"7"="(7)~CD11b^{'+'}~cDCs",
"8"="(8)~CX3CR1^{'-'}*Ly6C^{int}~monocytes",
"9"="(9)~CD4^{'+'}~pDCs", 
"10"="(10)~Ly6C^{'-'}~lymphoid", 
"11"="(11)~Ly6C^{'+'}~T[helper]",
"12"="(12)~Ly6C^{'-'}~T[helper]", # teal
"13"="(13)~CD64^{'+'}*MHCII^{'+'}~macrophages", # teal
"14"="(14)~CD64^{'+'}*MHCII^{'-'}~macrophages",
"15"="(15)~NK~cells", # dark green
"16"="(16)~Microglia", # mustard
"18"="(17)~B~cells" # 
) 

cluster_equivalent_labels = as.vector(labeller)

# Make it a factor with levels in right order for plotting
cluster_equivalent_labels <- factor(cluster_equivalent_labels, levels=as.character(cluster_equivalent_labels), ordered=TRUE)
```


Set cluster number
```{r}

dr$cell_clustering_k18 <- factor(cell_clustering_k18[tsne_inds], levels = 1:18) 
dr$annotation <- factor(labeller[match(dr$cell_clustering_k18, names(labeller))], levels=cluster_equivalent_labels, ordered=T)

```

Figure S13B heatmap
Include all clustered cells, not just those used to generate tsne
```{r}

plot_clustering_heatmap_wrapper(expr =  expr_ds[!cell_clustering_k18==17, lineage_markers_ord],
  expr01 = expr01_ds[!cell_clustering_k18==17, lineage_markers_ord],
  cell_clustering = labeller[match(cell_clustering_k18, names(labeller))][!cell_clustering_k18==17], color_clusters = color_clusters, filename = paste(here::here("pics/"),"apollo_men_6to20k_clusters_k18.pdf",sep=""),width=9.5,height=3.7) # Including cluster 6 as well
```

Figure S3A left hand panel
```{r}
tsne_manual <- ggplot(dr[dr$drop==TRUE,],  aes(x = tSNE1, y = tSNE2, color = manual_labels)) +
  geom_point(size = 0.1) +
  theme_bw() +
  scale_color_manual(values = colors_manual, labels=parse(text=levels(dr$manual_labels))) +
  guides(color = guide_legend(override.aes = list(size = 4), ncol = 1,title="Manual flowJo\ngating",label.position="left")) +
  theme(legend.text=element_text(size=8)) +
  coord_fixed() # LOCK the aspect ratio
tsne_manual

```

Figure S3A right-hand panel and Figure 3A
Plot tSNE with automatic labels
```{r}

tsne_automatic <- ggplot(dr[dr$drop==TRUE,],  aes(x = tSNE1, y = tSNE2, color = annotation)) +
  geom_point(size = 0.1) +
  theme_bw() +
  scale_color_manual(values = color_clusters, labels=parse(text=levels(cluster_equivalent_labels))) +
  guides(color = guide_legend(override.aes = list(size = 4), ncol = 1,title="Autogating",label.position="left")) + # [-17] drops the <0.1% cluster
  theme(legend.text=element_text(size=8)) +
  coord_fixed() # LOCK the aspect ratio
tsne_automatic

ggsave(tsne_automatic, filename = "apollo_men_tsne_auto_labels.eps", path=here::here("pics/"), height = 7, width = 8)

library(cowplot)
plot_grid(tsne_manual, tsne_automatic, ncol=2, align="hv")
ggsave("apollo_men_tsne_both.png", path=here::here("pics/"), height = 7, width = 16)
```

```{r}

counts_table <- table(cell_clustering_k18, sample_ids_ds) 
props_table <- t(t(counts_table) / colSums(counts_table)) * 100

counts_men <- as.data.frame.matrix(counts_table)
props <- as.data.frame.matrix(props_table)

```

```{r}

library(lme4) 
library(multcomp)

# Must make everything a factor:
md$strain <- factor(md$strain, ordered=FALSE)
md$condition <- factor(md$condition, ordered=FALSE)
md$coh <- factor(md$coh, ordered=FALSE)

```

Median marker expression
```{r}

FDR_cutoff <- 0.05

## Get median marker expression per sample and cluster
functional_markers2 <- c("CD69","MHCII","CX3CR1","Ly6C","CD45","CD11b")

expr_median_sample_cluster_tbl <- data.frame(expr_ds[, functional_markers2],
  sample_id = sample_ids_ds, cluster = cell_clustering_k18) %>%
  group_by(sample_id, cluster) %>% dplyr::filter(!cluster==17) %>% 
  summarize_all(funs(median)) # Drops bad cluster 17

## Melt
expr_median_sample_cluster_melt <- melt(expr_median_sample_cluster_tbl,
  id.vars = c("sample_id", "cluster"), value.name = "median_expression",
  variable.name = "antigen")
## Rearange so the rows represent clusters and markers
expr_median_sample_cluster <- dcast(expr_median_sample_cluster_melt,
  cluster + antigen ~ sample_id,  value.var = "median_expression")
rownames(expr_median_sample_cluster) <- paste0(expr_median_sample_cluster$cluster,
  "_", expr_median_sample_cluster$antigen)

ggdf <- expr_median_sample_cluster_melt
mm <- match(ggdf$sample_id, md$sample_id)
ggdf$condition <- factor(md$condition[mm])
ggdf$strain <- factor(md$strain[mm])
ggdf$coh <- factor(md$coh[mm])
```

This function is adapted from https://f1000research.com/articles/6-748/v2 (added AIC and estimates):
"We created a wrapper function differential_expression_wrapper that performs the differential analysis of marker expression. The user needs to specify a data frame expr_median with marker expression, where each column corresponds to a sample and each row to a cluster/marker combination. One can choose between fitting a regular linear model model = "lm" or a linear mixed model model = "lmer". The formula parameter must be adjusted adequately to the model choice. The wrapper function returns the non-adjusted and adjusted p-values for each of the specified contrasts K for each cluster/marker combination."
```{r}

differential_expression_wrapper <- function(expr_median, md, model = "lmer", formula, K){
  ## Fit LMM or LM for each marker separately
  fit_gaussian <- lapply(1:nrow(expr_median), function(i){
    data_tmp <- data.frame(y = as.numeric(expr_median[i, md$sample_id]), md)
    switch(model,
      lmer = {
        fit_tmp <- lmer(formula, data = data_tmp)
      },
      lm = {
        fit_tmp <- lm(formula, data = data_tmp)
      })
    AICed <- AIC(fit_tmp) # There will be an AIC for each channel, each cluster
    ## Fit contrasts one by one, if they exist
    est_csd <- coef(fit_tmp)["conditioncsd"]
    est_cd19 <- coef(fit_tmp)["straincd19"]
    out <- apply(K, 1, function(k){
      contr_tmp <- glht(fit_tmp, linfct = matrix(k, 1))
      summ_tmp <- summary(contr_tmp)
      pval <- summ_tmp$test$pvalues
      return(pval)
    })
    return(list(out=out,AIC=AICed, est_csd=est_csd, est_cd19=est_cd19))
  })
  pvals <- do.call(rbind, lapply(fit_gaussian,`[[`,1))
  AICs <- do.call(rbind, lapply(fit_gaussian,`[[`,2))
  est_csd <- do.call(rbind, lapply(fit_gaussian,`[[`,3))
  est_cd19 <- do.call(rbind, lapply(fit_gaussian,`[[`,4))
  colnames(pvals) <- paste0("pval_", contrast_names)
  rownames(pvals) <- rownames(expr_median)
  names(AICs) <- rownames(expr_median)
  names(est_csd) <- rownames(expr_median)
  names(est_cd19) <- rownames(expr_median)
  ## Adjust the p-values
  adjp <- apply(pvals, 2, p.adjust, method = "BH")
  colnames(adjp) <- paste0("adjp_", contrast_names)
  return(list(pvals = pvals, adjp = adjp, AIC=AICs, est_csd=est_csd, est_cd19=est_cd19))
}

```


Function to plot heatmaps with p-value as square size
Makes Figure 3F and 5E
```{r}
plot_tilesize_heatmap <- function(de_out=NULL, adjp=NULL, filename=filename, width=8, height=10, fdr_blank=0.1, fdr_break=0.05, picpath=here::here("pics/"), labels=labels, limits=c(-20,20)){
  ppp <- de_out[,-1]
  eee <- adjp[,-1]
  ppp[eee>=fdr_blank] <- NA
  de_out_thh <- data.frame(cluster=labels, ppp)
  ppp2 <- reshape2::melt(de_out_thh, id.vars="cluster")  
  ppp2$padj <- reshape2::melt(adjp, id.vars="cluster")$value 
  ppp2$thh <- "Not sig"
  ppp2$thh[ppp2$padj<fdr_break] <- paste("p(adj)<",fdr_break,sep="")
  ppp2$thh[ppp2$padj>=fdr_break & ppp2$padj<fdr_blank] <- paste("p(adj)<",fdr_blank,sep="")
  ppp2$thh <- factor(ppp2$thh, levels=c("Not sig", paste("p(adj)<",fdr_blank,sep=""),paste("p(adj)<",fdr_break,sep="")), ordered=TRUE)
  t_max <- max(ppp2$value, na.rm=TRUE)
  print(t_max)
  if(t_max<0){t_max=5}
  print(t_max)
  t_min <- min(ppp2$value, na.rm=TRUE)
  print(t_min)
  if(t_min>0){t_min=-5}
  print(t_min)
  head(ppp2)
  cols <- rev(c("#67001F","#B2182B","#F4A582","#F7F7F7","#92C5DE","#2166AC","#053061"))
  p <- ggplot(ppp2, aes(x=variable, y=cluster, fill=value, size=thh)) + geom_point(shape=22) + scale_size_manual(values=c("Not sig"=0,"p(adj)<0.1"=3,"p(adj)<0.05"=6)) + scale_y_discrete(limits=rev(levels(ppp2$cluster)),labels = parse(text=rev(levels(ppp2$cluster)))) + # Had to reverse to get 1 at the top 
    theme_minimal() + 
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.5 ), legend.title = element_text(size=10)) + 
    coord_fixed() +
    scale_fill_gradientn(colours=cols, limits=limits) + xlab("") + ylab("") +
    guides(fill=guide_colorbar(title="Coefficient"), size=guide_legend(title="Significance"))
  ggsave(plot=p, path=here::here("pics/"), filename=filename,width=width,height=height)
  p
}

```

Statistics and tileplots for effects of stress in WT animals
```{r}
formula_lm <- y ~ condition + coh

model.matrix( ~ condition + coh, data = md)
contrast_names <- c("condition")
k1 <- c(0,1,0,0,0,0,0,0)
K <- matrix(c(k1), nrow = 1, byrow = TRUE, dimnames = list(contrast_names))
K

# Now make the expr_median_sample_cluster without the CSDs included
nocd19 <- md %>% dplyr::filter(strain=="wt") %>% dplyr::select(sample_id) %>% pull

expr_median_nocd19 <- expr_median_sample_cluster[,c("cluster","antigen",nocd19)]

de_out_nocd19 <- differential_expression_wrapper(expr_median = expr_median_nocd19,
  md = md %>% dplyr::filter(strain=="wt"), model = "lm", formula = formula_lm, K = K)

apply(de_out_nocd19$adjp < FDR_cutoff, 2, table) 

de_output_nocd19 <- data.frame(expr_median_nocd19,
  de_out_nocd19$pvals, de_out_nocd19$adjp, de_out_nocd19$est_csd, row.names = NULL)
print(head(de_output_nocd19), digits = 2)

de_out_nocd19_spread <- spread(de_output_nocd19[,c("cluster","antigen","conditioncsd")], antigen, conditioncsd)

de_out_nocd19_spread.adjp <- spread(de_output_nocd19[,c("cluster","antigen","adjp_condition")], antigen, adjp_condition)

# FIGURE 3F
plot_tilesize_heatmap(de_out=de_out_nocd19_spread, adjp=de_out_nocd19_spread.adjp, filename="apollo_de_out_nocd19_spread_men_tile.pdf", width=4.5, height=3.75, fdr_blank=0.1, fdr_break=0.05, picpath=here::here("pics/"), labels=cluster_equivalent_labels)

```


Tileplots for effects of strain in HC animals
```{r}
formula_lm <- y ~ strain + coh

model.matrix( ~ strain + coh, data = md)
contrast_names <- c("strain")
k1 <- c(0,1,0,0,0,0,0,0)
K <- matrix(c(k1), nrow = 1, byrow = TRUE, dimnames = list(contrast_names))
K

# Now make the expr_median_sample_cluster without the CSDs included
nocsd <- md %>% dplyr::filter(condition=="hc") %>% dplyr::select(sample_id) %>% pull

expr_median_nocsd <- expr_median_sample_cluster[,c("cluster","antigen",nocsd)]

# Version with nocsd
de_out_nocsd <- differential_expression_wrapper(expr_median = expr_median_nocsd,
  md = md %>% dplyr::filter(condition=="hc"), model = "lm", formula = formula_lm, K = K)

apply(de_out_nocsd$adjp < FDR_cutoff, 2, table) 
# 12 TURE

de_output_nocsd <- data.frame(expr_median_nocsd,
  de_out_nocsd$pvals, de_out_nocsd$adjp, de_out_nocsd$est_cd19, row.names = NULL)
print(head(de_output_nocsd), digits = 2)

de_out_nocsd_spread <- spread(de_output_nocsd[,c("cluster","antigen","straincd19")], antigen, straincd19)

de_out_nocsd_spread.adjp <- spread(de_output_nocsd[,c("cluster","antigen","adjp_strain")], antigen, adjp_strain)

# FIGURE 5E
plot_tilesize_heatmap(de_out=de_out_nocsd_spread, adjp=de_out_nocsd_spread.adjp, filename="apollo_de_out_nocsd_spread_men_tile.pdf", width=4.5, height=3.75, fdr_blank=0.1, fdr_break=0.05, picpath=here::here("pics/"), labels=cluster_equivalent_labels)

```

Use DESeq2 to look for changes in abundance
```{r}
library(DESeq2)
# Create a data frame of the design matrix as requred by DESeqDataSetFromMatrix
counts_men <- counts_men[-17,]
coldata <- md
dds <- DESeqDataSetFromMatrix(countData=counts_men, colData=coldata, design= ~ coh + strain + condition + strain:condition) # Version with cohort
dds
# Must do libcorr as have included fewer counts from some mice
colSums(counts_men) # see!
dds <- DESeq(dds)
plotDispEsts(dds, main="Dispersion plot")
rld <- rlogTransformation(dds, blind=TRUE)
resultsNames(dds)
```

Makes Figure S4B
Plot effects of stress in WT animal. Taking labelling fdr down to 0.4 so can show that the trends are the same as for absolute counts.
```{r}
res <- results(dds,name="condition_csd_vs_hc")
resdata <- merge(as.data.frame(res), as.data.frame(counts(dds, normalized=FALSE)), by="row.names", sort=FALSE) 
names(resdata)[1] <- "Subset"
head(resdata[order(resdata$padj),])

res2 = mutate(resdata, sig=ifelse(resdata$padj<0.05, "FDR<0.05", "Not Sig"))
rownames(res2) <- cluster_equivalent_labels
library(ggrepel)
p = ggplot(res2, aes(res2$log2FoldChange, -log10(res2$pvalue))) +
  geom_point(aes(col=sig, size=sig)) +
  scale_color_manual(values=c("red", "black")) +
  scale_size_manual(values=c(3,2)) +
  geom_text_repel(data=dplyr::filter(res2, res2$padj<0.5), aes(dplyr::filter(res2, res2$padj<0.5)[,"log2FoldChange"], -log10(dplyr::filter(res2, res2$padj<0.5)[,"pvalue"]),label=rownames(res2[res2$padj<0.5,])),min.segment.length = unit(0, "lines"), size=7,segment.colour = "black", parse=TRUE, box.padding=unit(0.4,"lines")) +
  xlab("log2(Fold Change)") +
  ylab("-log10 (p-value)") +
  theme_bw() +
  theme(panel.background = element_rect(colour="white"), legend.justification=c(0,0), legend.position=c(0,0), legend.background = element_rect(color="black", fill="white",size=.5, linetype="solid"), legend.text=element_text(size=20), axis.text = element_text(size=20), axis.title = element_text(size=20)) +
  xlim(-1.5,1.5) +
  labs(col=NULL) +
  guides(size=FALSE, col=guide_legend(keywidth=0.05,keyheight=1.5)) +
  geom_vline(xintercept=0, linetype="dashed")
p
ggsave(p,path=here::here("pics/"),filename="apollo_volcano_counts_stress_hc_AUTOMATED.pdf",width=6,height=6)
```

```{r}

sessionInfo()

```
